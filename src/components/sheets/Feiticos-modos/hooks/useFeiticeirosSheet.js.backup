// hooks/useFeiticeirosSheet.js - VERS√ÉO 100% COMPAT√çVEL COM NOVAS ENDPOINTS
import React, { useState, useEffect, useMemo, useRef } from 'react';
import { calculateModifier, calculateAdditionalValues, validateNumberInput, calcularTotalPericia } from '../utils/characterCalculations';
import { 
  DEFAULT_ATTRIBUTES, 
  FIXED_VALUES, 
  TABELA_CUSTOS, 
  PERICIAS, 
  OFICIOS, 
  RESISTENCIAS, 
  ATAQUES,
  ESPECIALIZACOES_PV,
  ESPECIALIZACOES_PE,
  METODOS_CRIACAO
} from '../constants/characterSheet';

// Constantes imut√°veis
const FIELD_CONFIG = {
  nivel: { display: 'N√≠vel', desc: 'N√≠vel atual do personagem' },
  origem: { display: 'Origem', desc: 'Origem ou background do personagem' },
  treino: { display: 'Treino', desc: 'B√¥nus de treinamento' },
  especializacao: { display: 'Especializa√ß√£o', desc: 'Especializa√ß√£o principal' },
  tecnica: { display: 'T√©cnica', desc: 'T√©cnica ou escola de feiti√ßaria' },
  experiencia: { display: 'Experi√™ncia (EXP)', desc: 'Pontos de experi√™ncia acumulados' },
  multiclasse: { display: 'Multiclasse', desc: 'Classes adicionais' },
  grau: { display: 'Grau', desc: 'Grau de poder do feiticeiro' }
};

const WHEEL_CONFIG = [
  { angle: 45, name: 'SABEDORIA' },
  { angle: 90, name: 'DESTREZA' },
  { angle: 135, name: 'CONSTITUI√á√ÉO' },
  { angle: 225, name: 'INTELIG√äNCIA' },
  { angle: 270, name: 'FOR√áA' },
  { angle: 315, name: 'PRESEN√áA' },
  { angle: 0, type: 'empty' },
  { angle: 180, type: 'empty' }
];

// Debounce factory
const createDebounce = (wait) => {
  let timeout;
  return (func) => {
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  };
};

export const useFeiticeirosSheet = (character, onUpdate, diceRollModal) => {
  console.log('üî• useFeiticeirosSheet RENDER - characterId:', character?.id);
  
  // Estado consolidado - INICIALIZADO COM DADOS DO CHARACTER
  const [state, setState] = useState(() => {
    // CARREGAR DADOS DO CHARACTER NA INICIALIZA√á√ÉO
    const hasFeiticeirosAttributes = character?.feiticeiros_attributes && character.feiticeiros_attributes.length > 0;
    
    return {
      // UI states
      showMethodSelection: !hasFeiticeirosAttributes, // Mostrar seletor apenas se n√£o tiver atributos
      selectedMethod: null,
      showDistribution: false,
      editDialog: { open: false, type: '', title: '' },
      isLoading: false,
      localErrors: {},
      
      // Estados para Derived Values
      showDerivedValuesModal: false,
      derivedValuesBonuses: character?.derived_values_bonuses || {
        atencao: 0,
        defesa: 0,
        iniciativa: 0,
        deslocamento: 0
      },
      
      // Attribute states - INICIALIZAR COM DADOS DO BANCO
      localAttributes: hasFeiticeirosAttributes 
        ? DEFAULT_ATTRIBUTES.map(defaultAttr => {
            const charAttr = character.feiticeiros_attributes.find(attr => 
              attr.attribute?.name === defaultAttr.name
            );
            return {
              ...defaultAttr,
              value: charAttr?.value || defaultAttr.value
            };
          })
        : DEFAULT_ATTRIBUTES,
      availableValues: [...FIXED_VALUES],
      distributionAttributes: [...DEFAULT_ATTRIBUTES],
      pontosDisponiveis: 17,
      
      // RECURSOS SEPARADOS CONFORME PDF - COM DADOS DO BANCO
      currentHP: character?.current_hit_points || 0,
      currentSoul: character?.current_soul_integrity || 0,
      currentPE: character?.current_energy_points || 0,
      maxHP: character?.max_hit_points || 10,
      maxPE: character?.max_energy_points || 0,
      
      // List states - CARREGAR DO BANCO SE EXISTIR
      pericias: character?.feiticeiros_pericias && character.feiticeiros_pericias.length > 0 
        ? PERICIAS.map(pericia => {
            const charPericia = character.feiticeiros_pericias.find(p => p.nome === pericia.nome);
            return charPericia ? { ...pericia, ...charPericia } : pericia;
          })
        : [...PERICIAS],
      oficios: character?.feiticeiros_oficios && character.feiticeiros_oficios.length > 0
        ? OFICIOS.map(oficio => {
            const charOficio = character.feiticeiros_oficios.find(o => o.nome === oficio.nome);
            return charOficio ? { ...oficio, ...charOficio } : oficio;
          })
        : [...OFICIOS],
      resistencias: character?.feiticeiros_resistencias && character.feiticeiros_resistencias.length > 0
        ? RESISTENCIAS.map(resistencia => {
            const charResistencia = character.feiticeiros_resistencias.find(r => r.nome === resistencia.nome);
            return charResistencia ? { ...resistencia, ...charResistencia } : resistencia;
          })
        : [...RESISTENCIAS],
      ataques: character?.feiticeiros_ataques && character.feiticeiros_ataques.length > 0
        ? ATAQUES.map(ataque => {
            const charAtaque = character.feiticeiros_ataques.find(a => a.nome === ataque.nome);
            return charAtaque ? { ...ataque, ...charAtaque } : ataque;
          })
        : [...ATAQUES],
      
      // Character info - COM DADOS DO BANCO
      characterInfo: {
        nivel: character?.level || 1,
        origem: character?.origem || '',
        treino: character?.treino || '',
        especializacao: character?.especializacao || '',
        tecnica: character?.tecnica || '',
        experiencia: character?.experiencia || 0,
        multiclasse: character?.multiclasse || '',
        grau: character?.grau || ''
      }
    };
  });

  // REF PRINCIPAL PARA ESTABILIDADE
  const stableRef = useRef({
    character,
    onUpdate,
    diceRollModal,
    characterInfo: state.characterInfo,
    
    // Debounce otimizado para diferentes tipos de update
    debouncedCharacterUpdate: createDebounce(150)((field, value) => {
      if (stableRef.current.character && stableRef.current.onUpdate) {
        console.log('üî• Debounced character update:', field, value);
        stableRef.current.onUpdate('character', field, value);
      }
    }),

    debouncedFeiticeirosUpdate: createDebounce(150)((type, identifier, data) => {
      if (stableRef.current.character && stableRef.current.onUpdate) {
        console.log('üî• Debounced feiticeiros update:', type, identifier, data);
        stableRef.current.onUpdate(type, identifier, data);
      }
    }),

    // HANDLERS PRINCIPAIS
    handleCharacterInfoUpdate: (field, value) => {
      console.log('üî• handleCharacterInfoUpdate:', field, value);
      setState(prev => {
        const newCharacterInfo = { ...prev.characterInfo, [field]: value };
        stableRef.current.characterInfo = newCharacterInfo;
        stableRef.current.debouncedCharacterUpdate(field, value);
        return { ...prev, characterInfo: newCharacterInfo };
      });
    },

    handleCharacterInfoClick: (field) => {
      console.log('üî• handleCharacterInfoClick:', field);
      const config = FIELD_CONFIG[field] || { display: field, desc: '' };
      
      setState(prev => ({
        ...prev,
        editDialog: {
          open: true,
          type: 'characterInfo',
          title: `Editar ${config.display}`,
          field: field,
          current: stableRef.current.characterInfo[field],
          description: config.desc
        }
      }));
    },

    // Handlers para Derived Values
    handleOpenDerivedValuesModal: () => {
      console.log('üî• handleOpenDerivedValuesModal');
      setState(prev => ({
        ...prev,
        showDerivedValuesModal: true
      }));
    },

    handleCloseDerivedValuesModal: () => {
      console.log('üî• handleCloseDerivedValuesModal');
      setState(prev => ({
        ...prev,
        showDerivedValuesModal: false
      }));
    },

    handleSaveDerivedValuesBonuses: (newBonuses) => {
      console.log('üî• handleSaveDerivedValuesBonuses:', newBonuses);
      setState(prev => ({
        ...prev,
        derivedValuesBonuses: newBonuses,
        showDerivedValuesModal: false
      }));

      // Salvar no character
      if (stableRef.current.character && stableRef.current.onUpdate) {
        stableRef.current.onUpdate('character', 'derived_values_bonuses', newBonuses);
      }
    },

    handleSaveEdit: (type, current, max, field) => {
      console.log('üî• handleSaveEdit:', type, current, max, field);
      if (type === 'hp') {
        const newCurrent = Math.max(0, current);
        const newMax = Math.max(1, max);
        
        setState(prev => ({
          ...prev,
          currentHP: newCurrent,
          maxHP: newMax
        }));

        if (stableRef.current.character && stableRef.current.onUpdate) {
          stableRef.current.onUpdate('character', 'current_hit_points', newCurrent);
          stableRef.current.onUpdate('character', 'max_hit_points', newMax);
        }
      } else if (type === 'soul') {
        const newCurrent = Math.max(0, current);
        
        setState(prev => ({
          ...prev,
          currentSoul: newCurrent
        }));

        if (stableRef.current.character && stableRef.current.onUpdate) {
          stableRef.current.onUpdate('character', 'current_soul_integrity', newCurrent);
        }
      } else if (type === 'energy') {
        const newCurrent = Math.max(0, current);
        const newMax = Math.max(1, max);
        
        setState(prev => ({
          ...prev,
          currentPE: newCurrent,
          maxPE: newMax
        }));

        if (stableRef.current.character && stableRef.current.onUpdate) {
          stableRef.current.onUpdate('character', 'current_energy_points', newCurrent);
          stableRef.current.onUpdate('character', 'max_energy_points', newMax);
        }
      } else if (type === 'characterInfo' && field) {
        stableRef.current.handleCharacterInfoUpdate(field, current);
      }
      
      setState(prev => ({ ...prev, editDialog: { open: false, type: '', title: '' } }));
    },

    handleHealthClick: () => {
      console.log('üî• handleHealthClick');
      setState(prev => ({
        ...prev,
        editDialog: {
          open: true,
          type: 'hp',
          title: 'Editar Pontos de Vida',
          current: prev.currentHP,
          max: prev.maxHP,
          description: 'Pontos de Vida atuais e m√°ximos do personagem'
        }
      }));
    },

    handleSoulClick: () => {
      console.log('üî• handleSoulClick');
      setState(prev => ({
        ...prev,
        editDialog: {
          open: true,
          type: 'soul',
          title: 'Editar Integridade da Alma',
          current: prev.currentSoul,
          max: prev.maxHP,
          description: 'Integridade da Alma atual (m√°ximo igual aos Pontos de Vida)'
        }
      }));
    },

    handleEnergyClick: () => {
      console.log('üî• handleEnergyClick');
      setState(prev => ({
        ...prev,
        editDialog: {
          open: true,
          type: 'energy',
          title: 'Editar Pontos de Energia Amaldi√ßoada (PE)',
          current: prev.currentPE,
          max: prev.maxPE,
          description: 'Pontos de Energia Amaldi√ßoada atuais e m√°ximos do personagem'
        }
      }));
    },

    handleQuickAction: (type, amount) => {
      console.log('üî• handleQuickAction:', type, amount);
      setState(prev => {
        const updates = {
          heal: () => [Math.min(prev.maxHP, prev.currentHP + amount), 'current_hit_points'],
          damage: () => [Math.max(0, prev.currentHP - amount), 'current_hit_points'],
          soul_heal: () => [Math.min(prev.maxHP, prev.currentSoul + amount), 'current_soul_integrity'],
          soul_damage: () => [Math.max(0, prev.currentSoul - amount), 'current_soul_integrity'],
          energy: () => [Math.min(prev.maxPE, prev.currentPE + amount), 'current_energy_points'],
          energy_remove: () => [Math.max(0, prev.currentPE - amount), 'current_energy_points']
        };

        const [newValue, field] = updates[type]?.() || [];
        if (newValue === undefined) return prev;

        const newState = {
          ...prev,
          ...(type === 'heal' || type === 'damage' ? { currentHP: newValue } : 
              type === 'soul_heal' || type === 'soul_damage' ? { currentSoul: newValue } : 
              { currentPE: newValue })
        };

        if (stableRef.current.character && stableRef.current.onUpdate) {
          stableRef.current.onUpdate('character', field, newValue);
        }

        return newState;
      });
    },

    handleToggleTreinada: (itemNome, checked, tipo, modulo) => {
      console.log('üî• handleToggleTreinada:', itemNome, checked, tipo, modulo);
      setState(prev => ({
        ...prev,
        [modulo]: prev[modulo].map(p => {
          if (p.nome !== itemNome) return p;
          if (tipo === 'treinada') return { ...p, treinada: checked };
          if (tipo === 'mestre') return { ...p, mestre: checked, treinada: checked ? true : p.treinada };
          return p;
        })
      }));

      // Salvar no banco usando as NOVAS ENDPOINTS
      if (stableRef.current.character && stableRef.current.onUpdate) {
        const endpointMap = {
          pericias: 'feiticeiros_pericia',
          oficios: 'feiticeiros_oficio', 
          resistencias: 'feiticeiros_resistencia',
          ataques: 'feiticeiros_ataque'
        };
        
        const endpoint = endpointMap[modulo];
        if (endpoint) {
          const updatedItem = state[modulo].find(p => p.nome === itemNome);
          if (updatedItem) {
            stableRef.current.debouncedFeiticeirosUpdate(
              endpoint, 
              itemNome, 
              {
                characterId: stableRef.current.character.id,
                [`${modulo.slice(0, -1)}Nome`]: itemNome,
                data: {
                  treinada: tipo === 'mestre' ? true : checked,
                  mestre: tipo === 'mestre' ? checked : updatedItem.mestre,
                  outros: updatedItem.outros || 0,
                  atributo: updatedItem.atributo,
                  descricao: updatedItem.descricao
                }
              }
            );
          }
        }
      }
    },

    handleOutrosChange: (itemNome, outros, modulo) => {
      console.log('üî• handleOutrosChange:', itemNome, outros, modulo);
      setState(prev => ({
        ...prev,
        [modulo]: prev[modulo].map(p => 
          p.nome === itemNome ? { ...p, outros } : p
        )
      }));

      // Salvar no banco usando as NOVAS ENDPOINTS
      if (stableRef.current.character && stableRef.current.onUpdate) {
        const endpointMap = {
          pericias: 'feiticeiros_pericia',
          oficios: 'feiticeiros_oficio',
          resistencias: 'feiticeiros_resistencia', 
          ataques: 'feiticeiros_ataque'
        };
        
        const endpoint = endpointMap[modulo];
        if (endpoint) {
          const updatedItem = state[modulo].find(p => p.nome === itemNome);
          if (updatedItem) {
            stableRef.current.debouncedFeiticeirosUpdate(
              endpoint,
              itemNome,
              {
                characterId: stableRef.current.character.id,
                [`${modulo.slice(0, -1)}Nome`]: itemNome,
                data: {
                  treinada: updatedItem.treinada || false,
                  mestre: updatedItem.mestre || false,
                  outros: parseInt(outros) || 0,
                  atributo: updatedItem.atributo,
                  descricao: updatedItem.descricao
                }
              }
            );
          }
        }
      }
    },

    handlePericiaRoll: (pericia, total) => {
      console.log('üî• handlePericiaRoll:', pericia.nome, total);
      if (stableRef.current.character && stableRef.current.diceRollModal) {
        stableRef.current.diceRollModal.appear({
          characterId: stableRef.current.character.id,
          characterName: stableRef.current.character.name,
          skillName: pericia.nome,
          skillValue: total,
          skillDescription: `${pericia.descricao} (${pericia.atributo})`
        });
      }
    },

    handleMethodSelect: (method) => {
      console.log('üî• handleMethodSelect:', method.id);
      setState(prev => ({
        ...prev,
        selectedMethod: method,
        showMethodSelection: false,
        showDistribution: true
      }));
      
      if (method.id === 'FIXOS') {
        setState(prev => ({
          ...prev,
          availableValues: [...FIXED_VALUES],
          distributionAttributes: DEFAULT_ATTRIBUTES.map(attr => ({
            ...attr,
            value: 10,
            assignedValue: null
          })),
          pontosDisponiveis: 17
        }));
      } else if (method.id === 'COMPRA') {
        setState(prev => ({
          ...prev,
          pontosDisponiveis: 17,
          distributionAttributes: DEFAULT_ATTRIBUTES.map(attr => ({
            ...attr,
            value: 10
          }))
        }));
      }
    },

    assignValueToAttribute: (attributeIndex, value) => {
      console.log('üî• assignValueToAttribute:', attributeIndex, value);
      setState(prev => {
        const newAttributes = [...prev.distributionAttributes];
        const attribute = newAttributes[attributeIndex];
        
        if (attribute.assignedValue !== null) {
          const newAvailableValues = [...prev.availableValues, attribute.assignedValue].sort((a, b) => b - a);
          return {
            ...prev,
            availableValues: newAvailableValues,
            distributionAttributes: newAttributes.map((attr, idx) => 
              idx === attributeIndex ? { ...attr, assignedValue: value, value: value } : attr
            )
          };
        }
        
        return {
          ...prev,
          availableValues: prev.availableValues.filter(v => v !== value),
          distributionAttributes: newAttributes.map((attr, idx) => 
            idx === attributeIndex ? { ...attr, assignedValue: value, value: value } : attr
          )
        };
      });
    },

    removeValueFromAttribute: (attributeIndex) => {
      console.log('üî• removeValueFromAttribute:', attributeIndex);
      setState(prev => {
        const newAttributes = [...prev.distributionAttributes];
        const attribute = newAttributes[attributeIndex];
        
        if (attribute.assignedValue !== null) {
          const newAvailableValues = [...prev.availableValues, attribute.assignedValue].sort((a, b) => b - a);
          return {
            ...prev,
            availableValues: newAvailableValues,
            distributionAttributes: newAttributes.map((attr, idx) => 
              idx === attributeIndex ? { ...attr, assignedValue: null, value: 10 } : attr
            )
          };
        }
        
        return prev;
      });
    },

    calcularCustoAtributo: (valorAtual, novoValor) => {
      const custoAtual = TABELA_CUSTOS[valorAtual] || 0;
      const custoNovo = TABELA_CUSTOS[novoValor] || 0;
      return custoNovo - custoAtual;
    },

    ajustarAtributoCompra: (attributeIndex, novoValor) => {
      console.log('üî• ajustarAtributoCompra:', attributeIndex, novoValor);
      if (novoValor < 8 || novoValor > 15) return;

      setState(prev => {
        const atributo = prev.distributionAttributes[attributeIndex];
        const custo = stableRef.current.calcularCustoAtributo(atributo.value, novoValor);
        
        if (prev.pontosDisponiveis >= custo) {
          const novosAtributos = [...prev.distributionAttributes];
          novosAtributos[attributeIndex] = { ...atributo, value: novoValor };
          
          return {
            ...prev,
            distributionAttributes: novosAtributos,
            pontosDisponiveis: prev.pontosDisponiveis - custo
          };
        }
        return prev;
      });
    },

    confirmDistribution: async () => {
      console.log('üî• confirmDistribution');
      setState(prev => ({ ...prev, isLoading: true }));
      try {
        setState(prev => ({ 
          ...prev, 
          localAttributes: prev.distributionAttributes,
          showDistribution: false 
        }));
        
        // SALVAR ATRIBUTOS USANDO AS NOVAS ENDPOINTS
        if (stableRef.current.character && stableRef.current.onUpdate) {
          const updatePromises = state.distributionAttributes.map(attr => {
            return new Promise((resolve) => {
              stableRef.current.debouncedFeiticeirosUpdate(
                'feiticeiros_attribute',
                attr.name,
                {
                  characterId: stableRef.current.character.id,
                  attributeName: attr.name,
                  value: attr.value
                }
              );
              resolve();
            });
          });
          
          await Promise.all(updatePromises);
        }
      } catch (error) {
        console.error('Erro ao confirmar distribui√ß√£o:', error);
        setState(prev => ({
          ...prev,
          localErrors: {
            ...prev.localErrors,
            distribution: 'Erro ao salvar atributos. Tente novamente.'
          }
        }));
      } finally {
        setState(prev => ({ ...prev, isLoading: false }));
      }
    },

    resetDistribution: () => {
      console.log('üî• resetDistribution');
      setState(prev => {
        if (prev.selectedMethod?.id === 'FIXOS') {
          return {
            ...prev,
            availableValues: [...FIXED_VALUES],
            distributionAttributes: DEFAULT_ATTRIBUTES.map(attr => ({
              ...attr,
              value: 10,
              assignedValue: null
            }))
          };
        } else if (prev.selectedMethod?.id === 'COMPRA') {
          return {
            ...prev,
            pontosDisponiveis: 17,
            distributionAttributes: DEFAULT_ATTRIBUTES.map(attr => ({
              ...attr,
              value: 10
            }))
          };
        } else if (prev.selectedMethod?.id === 'ROLAGEM') {
          return {
            ...prev,
            distributionAttributes: DEFAULT_ATTRIBUTES.map(attr => ({
              ...attr,
              value: 10
            }))
          };
        }
        return prev;
      });
      
      setState(prev => ({ 
        ...prev, 
        localErrors: { ...prev.localErrors, distribution: null } 
      }));
    },

    updateAttribute: (attributeName, value) => {
      console.log('üî• updateAttribute:', attributeName, value);
      const numValue = value === "" ? 0 : Math.max(0, Math.min(30, parseInt(value) || 0));
      
      setState(prev => ({
        ...prev,
        localAttributes: prev.localAttributes.map(attr => 
          attr.name === attributeName ? { ...attr, value: numValue } : attr
        )
      }));

      // SALVAR USANDO AS NOVAS ENDPOINTS
      if (stableRef.current.character && stableRef.current.onUpdate) {
        stableRef.current.debouncedFeiticeirosUpdate(
          'feiticeiros_attribute',
          attributeName,
          {
            characterId: stableRef.current.character.id,
            attributeName: attributeName,
            value: numValue
          }
        );
      }
    },

    handleAttributeRoll: (attributeName) => {
      console.log('üî• handleAttributeRoll:', attributeName);
      const attribute = state.localAttributes.find(attr => attr.name === attributeName);
      if (attribute && stableRef.current.character && stableRef.current.diceRollModal) {
        stableRef.current.diceRollModal.appear({
          characterId: stableRef.current.character.id,
          characterName: stableRef.current.character.name,
          skillName: attributeName,
          skillValue: attribute.value
        });
      }
    },

    handleInputChange: (e, callback, name) => {
      const value = e.target.value;
      if (value === '') {
        callback(name, '');
        return;
      }
      const numValue = parseInt(value);
      if (!isNaN(numValue)) callback(name, numValue);
    },

    handleBlur: (e, callback, name) => {
      const value = e.target.value;
      const validatedValue = validateNumberInput(value);
      callback(name, validatedValue);
    },

    handleKeyDown: (e, currentValue, callback, name) => {
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        callback(name, Math.min(30, currentValue + 1));
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        callback(name, Math.max(0, currentValue - 1));
      }
    },

    canConfirm: () => {
      if (state.selectedMethod?.id === 'FIXOS') {
        return state.availableValues.length === 0;
      }
      if (state.selectedMethod?.id === 'COMPRA') {
        return state.pontosDisponiveis >= 0;
      }
      return true;
    }
  });

  // Atualizar dados inst√°veis no ref quando mudarem
  useEffect(() => {
    console.log('üî• useFeiticeirosSheet - Props updated');
    stableRef.current.character = character;
    stableRef.current.onUpdate = onUpdate;
    stableRef.current.diceRollModal = diceRollModal;
  }, [character, onUpdate, diceRollModal]);

  useEffect(() => {
    stableRef.current.characterInfo = state.characterInfo;
  }, [state.characterInfo]);

  // C√°lculos pesados memoizados
  const wheelPositions = useMemo(() => {
    console.log('üî• useFeiticeirosSheet - Wheel positions calculated');
    const centerX = 260;
    const centerY = 280;
    const radius = 230;
    
    return WHEEL_CONFIG.map((pos) => {
      const rad = pos.angle * Math.PI / 180;
      const x = centerX + radius * Math.cos(rad);
      const y = centerY + radius * Math.sin(rad);
      
      return pos.name ? {
        x, y, type: 'attribute', angle: pos.angle, name: pos.name
      } : {
        x, y, type: 'empty', angle: pos.angle
      };
    });
  }, []);

  // CORRE√á√ÉO CR√çTICA: Passar per√≠cias para c√°lculo da ATEN√á√ÉO
  const additionalValues = useMemo(() => {
    console.log('üî• useFeiticeirosSheet - Additional values calculated');
    return calculateAdditionalValues(
      state.localAttributes, 
      state.characterInfo.nivel,
      state.characterInfo.especializacao,
      state.pericias
    );
  }, [state.localAttributes, state.characterInfo.nivel, state.characterInfo.especializacao, state.pericias]);

  // Valores derivados com b√¥nus aplicados
  const derivedValuesWithBonuses = useMemo(() => {
    console.log('üî• useFeiticeirosSheet - Derived values with bonuses calculated');
    const baseValues = {
      ATEN√á√ÉO: additionalValues?.ATEN√á√ÉO?.valor || 10,
      DEFESA: additionalValues?.DEFESA?.valor || 10,
      INICIATIVA: additionalValues?.INICIATIVA?.valor || 0,
      DESLOCAMENTO: additionalValues?.DESLOCAMENTO?.valor || 9
    };

    return {
      ATEN√á√ÉO: {
        ...additionalValues?.ATEN√á√ÉO,
        valor: baseValues.ATEN√á√ÉO + (state.derivedValuesBonuses.atencao || 0)
      },
      DEFESA: {
        ...additionalValues?.DEFESA,
        valor: baseValues.DEFESA + (state.derivedValuesBonuses.defesa || 0)
      },
      INICIATIVA: {
        ...additionalValues?.INICIATIVA,
        valor: baseValues.INICIATIVA + (state.derivedValuesBonuses.iniciativa || 0)
      },
      DESLOCAMENTO: {
        ...additionalValues?.DESLOCAMENTO,
        valor: baseValues.DESLOCAMENTO + (state.derivedValuesBonuses.deslocamento || 0)
      }
    };
  }, [additionalValues, state.derivedValuesBonuses]);

  // Canvas
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);

  const drawMahoragaWheels = () => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
    }

    animationFrameRef.current = requestAnimationFrame(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Desenho simplificado
      ctx.strokeStyle = 'rgba(74, 20, 140, 0.9)';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.arc(centerX, centerY, 120, 0, 2 * Math.PI);
      ctx.stroke();
      
      ctx.fillStyle = 'rgba(105, 27, 154, 1)';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 40, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.strokeStyle = 'rgba(106, 27, 154, 0.9)';
      ctx.lineWidth = 6;
      const connections = [[1, 4], [7, 6], [0, 3], [2, 5]];
      
      connections.forEach(([startIdx, endIdx]) => {
        const startPos = wheelPositions[startIdx];
        const endPos = wheelPositions[endIdx];
        if (startPos && endPos) {
          ctx.beginPath();
          ctx.moveTo(startPos.x, startPos.y);
          ctx.lineTo(endPos.x, endPos.y);
          ctx.stroke();
        }
      });
    });
  };

  useEffect(() => {
    drawMahoragaWheels();
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [drawMahoragaWheels, wheelPositions]);

  // CARREGAR DADOS QUANDO CHARACTER MUDAR
  useEffect(() => {
    console.log('üî• useFeiticeirosSheet - Character changed, reloading data');
    
    if (character) {
      const hasFeiticeirosAttributes = character.feiticeiros_attributes && character.feiticeiros_attributes.length > 0;
      
      // Atualizar atributos
      if (hasFeiticeirosAttributes) {
        const loadedAttributes = DEFAULT_ATTRIBUTES.map(defaultAttr => {
          const charAttr = character.feiticeiros_attributes.find(attr => 
            attr.attribute?.name === defaultAttr.name
          );
          return {
            ...defaultAttr,
            value: charAttr?.value || defaultAttr.value
          };
        });
        
        setState(prev => ({ 
          ...prev, 
          localAttributes: loadedAttributes,
          showMethodSelection: false 
        }));
      }

      // Atualizar character info
      const newCharacterInfo = {
        nivel: character.level || 1,
        origem: character.origem || '',
        treino: character.treino || '',
        especializacao: character.especializacao || '',
        tecnica: character.tecnica || '',
        experiencia: character.experiencia || 0,
        multiclasse: character.multiclasse || '',
        grau: character.grau || ''
      };
      
      setState(prev => ({
        ...prev,
        currentHP: character.current_hit_points || 0,
        currentSoul: character.current_soul_integrity || 0,
        currentPE: character.current_energy_points || 0,
        maxHP: character.max_hit_points || 10,
        maxPE: character.max_energy_points || 0,
        characterInfo: newCharacterInfo,
        derivedValuesBonuses: character.derived_values_bonuses || {
          atencao: 0,
          defesa: 0,
          iniciativa: 0,
          deslocamento: 0
        }
      }));
      
      stableRef.current.characterInfo = newCharacterInfo;
    }
  }, [character?.id]); // RECARREGA QUANDO O CHARACTER MUDAR

  // RETORNO SUPER EST√ÅVEL
  console.log('üî• useFeiticeirosSheet - Return API');

  return {
    // Estados
    ...state,
    
    // Refs e valores calculados
    canvasRef,
    wheelPositions,
    additionalValues,
    derivedValuesWithBonuses,
    
    // Setters
    setShowMethodSelection: (value) => setState(prev => ({ ...prev, showMethodSelection: value })),
    setShowDistribution: (value) => setState(prev => ({ ...prev, showDistribution: value })),
    setEditDialog: (value) => setState(prev => ({ ...prev, editDialog: value })),
    
    // HANDLERS EST√ÅVEIS
    handleCharacterInfoClick: stableRef.current.handleCharacterInfoClick,
    handleHealthClick: stableRef.current.handleHealthClick,
    handleSoulClick: stableRef.current.handleSoulClick,
    handleEnergyClick: stableRef.current.handleEnergyClick,
    handleSaveEdit: stableRef.current.handleSaveEdit,
    handleQuickAction: stableRef.current.handleQuickAction,
    handleToggleTreinada: stableRef.current.handleToggleTreinada,
    handleOutrosChange: stableRef.current.handleOutrosChange,
    handlePericiaRoll: stableRef.current.handlePericiaRoll,
    handleMethodSelect: stableRef.current.handleMethodSelect,
    assignValueToAttribute: stableRef.current.assignValueToAttribute,
    removeValueFromAttribute: stableRef.current.removeValueFromAttribute,
    ajustarAtributoCompra: stableRef.current.ajustarAtributoCompra,
    confirmDistribution: stableRef.current.confirmDistribution,
    resetDistribution: stableRef.current.resetDistribution,
    updateAttribute: stableRef.current.updateAttribute,
    handleAttributeRoll: stableRef.current.handleAttributeRoll,
    handleInputChange: stableRef.current.handleInputChange,
    handleBlur: stableRef.current.handleBlur,
    handleKeyDown: stableRef.current.handleKeyDown,
    canConfirm: stableRef.current.canConfirm,
    
    // Handlers para Derived Values
    handleOpenDerivedValuesModal: stableRef.current.handleOpenDerivedValuesModal,
    handleCloseDerivedValuesModal: stableRef.current.handleCloseDerivedValuesModal,
    handleSaveDerivedValuesBonuses: stableRef.current.handleSaveDerivedValuesBonuses
  };
};